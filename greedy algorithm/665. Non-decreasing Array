(Medium)
语言：Python
题目：给你一个长度为 n 的整数数组 nums ，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。

我们是这样定义一个非递减数列的： 对于数组中任意的 i (0 <= i <= n-2)，总满足 nums[i] <= nums[i + 1]。

 示例 1：
  输入: nums = [4,2,3]
  输出: true
  解释: 你可以通过把第一个 4 变成 1 来使得它成为一个非递减数列。
 
 示例 2：
  输入: nums = [4,2,1]
  输出: false
  解释: 你不能在只改变一个元素的情况下将其变为非递减数列。
 
这道题也是典型的贪心算法，只要保证在递归中的判断部分保证满足就是局部最优，但是从局部最优到全局最优的过程中，要考虑你的贪心
策略在各种情况下是否还是最优解

class Solution:
    def checkPossibility(self, nums: List[int]) -> bool:
        count = 0
        for i in range(1,len(nums)):
            if nums[i]<nums[i-1]:
                count +=1
                if count >=2: return False           #还要超过了2个直接返回，不用全部递归
                if i>1 and nums[i]<nums[i-2]:        
                    nums[i]=nums[i-1]                #如果是前面已经有放小的情况，后面就要考虑隔一个判断
        return True
        
 最开始写这道题目的解法时，只是考虑了相邻的两个元素，但是卡在了[3,4,2,3]这个用例。思考一下就会发现，由于前面3-4之间没有改变元素，
 那么后面在改变元素，就必须大于3且满足不递减的要求。因此需要对贪心策略进行修改
 
  
  
  
  
  
